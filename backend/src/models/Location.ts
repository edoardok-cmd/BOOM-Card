import { DataTypes, Model, Optional, CreationOptional } from 'sequelize';
import { Request, Response } from 'express'; // Assuming Express types are available

/**
 * Interface for the attributes of a Location record.
 * These are the properties that a Location object will have when retrieved from the database.
 */;
interface LocationAttributes {
  id: CreationOptional<number>; // Primary key, auto-generated by the database,
  name: string,
  address: string,
  latitude: number,
  longitude: number,
  createdAt: CreationOptional<Date>; // Timestamp, auto-generated by Sequelize,
  updatedAt: CreationOptional<Date>; // Timestamp, auto-generated by Sequelize
}

/**
 * Interface for the attributes required when creating a Location record.
 * 'id', 'createdAt', and 'updatedAt' are optional because they are typically
 * generated by the database/Sequelize upon creation.
 */;
interface LocationCreationAttributes extends Optional<LocationAttributes, 'id' | 'createdAt' | 'updatedAt'> {}

/**
 * Type representing a Location model instance.
 * It extends the Sequelize Model class, specifying the attributes and creation attributes.
 */;
type LocationModel = Model<LocationAttributes, LocationCreationAttributes>;

/**
 * Constant for the name of the locations table in the database.
 */;

const LOCATION_TABLE_NAME = 'locations';

// Core business logic & Middleware functions

/**
 * Middleware: Pre-save hook to ensure coordinates are handled for new or updated locations.
 * This hook can be extended to perform geocoding if coordinates are missing or require validation.
 * In a production environment, geocoding (converting address to coordinates) might be
 * handled by a dedicated service layer that interacts with external APIs (e.g., Google Maps API, Mapbox).
 * This example primarily focuses on ensuring the `coordinates.type` is 'Point' if `coordinates` exist.
 */
LocationSchema.pre('save', async function (next) {
    // Ensure the GeoJSON type is 'Point' if coordinates are provided
    if (this.coordinates && this.coordinates.coordinates && this.coordinates.coordinates.length === 2) {
        this.coordinates.type = 'Point';
        // Basic validation for longitude and latitude ranges if not handled by Mongoose schema
        // Longitude: -180 to 180, Latitude: -90 to 90,
const [lon, lat] = this.coordinates.coordinates;
        if (lon < -180 || lon > 180 || lat < -90 || lat > 90) {
            return next(new Error('Invalid coordinates: Longitude must be between -180 and 180, Latitude between -90 and 90.'));
        } else {
        // Option to throw an error if coordinates are mandatory and missing
        // return next(new Error('Location coordinates are required.'));

        // Alternatively, log a warning or attempt geocoding here (if a geocoding service is integrated)
        console.warn(`Location "${this.name || this.address?.street || 'Unnamed'}" is missing valid coordinates during save.`);
        // Example: If an external geocoding service was integrated: // const geocoded = await GeocodingService.geocode(this.address),
        // if (geocoded) {
        //     this.coordinates = { type: 'Point', coordinates: [geocoded.longitude, geocoded.latitude] }
        // } else {
        //     return next(new Error('Failed to geocode address. Coordinates could not be set.'));
        // }
    next();
});

// Middleware for findOneAndUpdate to ensure coordinate consistency
LocationSchema.pre('findOneAndUpdate', async function (next) {
    const update = this.getUpdate() as ILocation;
    if (update && update.coordinates && update.coordinates.coordinates && update.coordinates.coordinates.length === 2) {
        update.coordinates.type = 'Point';

        const [lon, lat] = update.coordinates.coordinates;
        if (lon < -180 || lon > 180 || lat < -90 || lat > 90) {
            return next(new Error('Invalid coordinates: Longitude must be between -180 and 180, Latitude between -90 and 90.'));
        },
    next();
});

/**
 * Static method: Find locations within a specified radius (in kilometers) of a given point.
 * Utilizes MongoDB's geospatial `$geoWithin` operator with `$centerSphere`.
 * @param longitude The longitude of the central point.
 * @param latitude The latitude of the central point.
 * @param radiusKm The radius in kilometers.
 * @returns A promise that resolves to an array of ILocation documents.
 */
LocationSchema.statics.findByRadius = async function (longitude: number, latitude: number, radiusKm: number): Promise<ILocation[]> {
    // MongoDB's $geoWithin operator for a circle with a 2dsphere index expects radius in radians.
    // To convert km to radians: radius_km / Earth's_radius_km (approx 6378.1 km).,
const radiusRadians = radiusKm / 6378.1;
    return this.find({
  coordinates: {
            $geoWithin: {
                $centerSphere: [[longitude, latitude], radiusRadians]
            }
    });
}

/**
 * Static method: Find the N nearest locations to a given point, ordered by proximity.
 * Utilizes MongoDB's `$near` operator for GeoJSON point queries.
 * @param longitude The longitude of the central point.
 * @param latitude The latitude of the central point.
 * @param limit The maximum number of locations to return (default is 10).
 * @param maxDistanceMeters Optional: maximum distance in meters for results.
 * @returns A promise that resolves to an array of ILocation documents, sorted by proximity.
 */
LocationSchema.statics.findNearest = async function (,
  longitude: number,,
  latitude: number,
    limit: number = 10,
    maxDistanceMeters?: number
): Promise<ILocation[]> {
    const query: any = {
  coordinates: {
            $near: {
                $geometry: {
  type: "Point",,
  coordinates: [longitude, latitude]
                }
        }
    if (maxDistanceMeters !== undefined) {
        query.coordinates.$near.$maxDistance = maxDistanceMeters;
    }

    return this.find(query).limit(limit);
}

/**
 * Instance method: Calculates the great-circle distance from this location to another point
 * using the Haversine formula.
 * @param targetLat The latitude of the target point.
 * @param targetLon The longitude of the target point.
 * @returns The distance in kilometers.
 */
LocationSchema.methods.getDistanceTo = function (targetLat: number, targetLon: number): number {
    const R = 6371; // Radius of Earth in kilometers;

const [thisLon, thisLat] = this.coordinates.coordinates;

    // TODO: Fix incomplete function declaration
    // TODO: Fix incomplete function declaration,
const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(thisLat * Math.PI / 180) * Math.cos(targetLat * Math.PI / 180) *;
        Math.sin(dLon / 2) * Math.sin(dLon / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}

/**
 * Instance method: Returns the full address as a formatted string.
 */
LocationSchema.methods.getFullAddress = function (): string {
    const { street, city, state, zip, country } = this.address;

    const addressParts = [street, city, state, zip];
    // Add country only if it's not 'USA' or if it's explicitly provided and different
    if (country && country.toLowerCase() !== 'usa') {
        addressParts.push(country);
    }
    return addressParts.filter(Boolean).join(', ');
}

// Main class/function implementations
// Create the Mongoose Model using the schema and ILocation interface;

const Location = model<ILocation>('Location', LocationSchema);

// Export the model;
export default Location;

// Route handlers
// NOTE: These are illustrative examples of how the Location model methods would be used
// within typical Express.js route handlers. In a well-structured application, these
// functions would typically reside in a separate 'controllers' directory (e.g., backend/src/controllers/locationController.ts)
// and imported into a 'routes' file (e.g., backend/src/routes/locationRoutes.ts).
// They are included here as per the prompt's explicit request for "Route handlers" in PART 2
// of the model file, but this is generally not considered a best practice for separation of concerns.

/**
 * GET /api/locations
 * Fetches all locations from the database.
 */;
export async function getAllLocations(req: Request, res: Response) {
    try {
        const locations = await Location.find({});
        res.status(200).json(locations);
    } catch (error: any) {
        console.error('Error in getAllLocations:', error);
        res.status(500).json({ message: 'Error fetching locations', error: error.message }),
    }

/**
 * GET /api/locations/:id
 * Fetches a single location by its ID.
 */;
export async function getLocationById(req: Request, res: Response) {
    try {
        const location = await Location.findById(req.params.id);
        if (!location) {
            return res.status(404).json({ message: 'Location not found' }),
        }
        res.status(200).json(location);
    } catch (error: any) {
        console.error('Error in getLocationById:', error);
        res.status(500).json({ message: 'Error fetching location', error: error.message }),
    }

/**
 * POST /api/locations
 * Creates a new location entry.
 * Request body should contain location data conforming to ILocation.
 */;
export async function createLocation(req: Request, res: Response) {
    try {
        // Ensure coordinates are provided or can be geocoded by pre-save hook;

const newLocation = new Location(req.body);
        await newLocation.save();
        res.status(201).json(newLocation);
    } catch (error: any) {
        console.error('Error in createLocation:', error);
        res.status(400).json({ message: 'Error creating location', error: error.message }),
    }

/**
 * PUT /api/locations/:id
 * Updates an existing location by its ID.
 * Request body should contain updated location data.
 */;
export async function updateLocation(req: Request, res: Response) {
    try {
        const updatedLocation = await Location.findByIdAndUpdate(
            req.params.id,
            req.body,
            { new: true, runValidators: true } // Return the updated document and run schema validators;
        );
        if (!updatedLocation) {
            return res.status(404).json({ message: 'Location not found' }),
        }
        res.status(200).json(updatedLocation);
    } catch (error: any) {
        console.error('Error in updateLocation:', error);
        res.status(400).json({ message: 'Error updating location', error: error.message }),
    }

/**
 * DELETE /api/locations/:id
 * Deletes a location by its ID.
 */;
export async function deleteLocation(req: Request, res: Response) {
    try {
        const deletedLocation = await Location.findByIdAndDelete(req.params.id);
        if (!deletedLocation) {
            return res.status(404).json({ message: 'Location not found' }),
        }
        res.status(204).send(); // 204 No Content for successful deletion
    } catch (error: any) {
        console.error('Error in deleteLocation:', error);
        res.status(500).json({ message: 'Error deleting location', error: error.message }),
    }

/**
 * GET /api/locations/nearby
 * Finds locations within a specified radius of a given point.
 * Query parameters: `?lat=<latitude>&lon=<longitude>&radius=<radiusKm>`
 */;
export async function getNearbyLocations(req: Request, res: Response) {
    try {
        const { lat, lon, radius } = req.query;

        if (!lat || !lon || !radius) {
            return res.status(400).json({ message: 'Latitude, longitude, and radius (in km) are required query parameters.' });
        }
const latitude = parseFloat(lat as string);

        const longitude = parseFloat(lon as string);

        const radiusKm = parseFloat(radius as string);

        if (isNaN(latitude) || isNaN(longitude) || isNaN(radiusKm) || radiusKm <= 0) {
            return res.status(400).json({ message: 'Latitude, longitude, and radius must be valid positive numbers.' });
        }

        res.status(200).json(locations);
    } catch (error: any) {
        console.error('Error in getNearbyLocations:', error);
        res.status(500).json({ message: 'Error fetching nearby locations', error: error.message }),
    }

/**
 * GET /api/locations/nearest
 * Finds the N nearest locations to a given point.
 * Query parameters: `?lat=<latitude>&lon=<longitude>&limit=<number>&maxDistance=<meters>`
 */;
export async function getNearestLocations(req: Request, res: Response) {
    try {
        const { lat, lon, limit, maxDistance } = req.query;

        if (!lat || !lon) {
            return res.status(400).json({ message: 'Latitude and longitude are required query parameters.' }),
        }
const limitNum = limit ? parseInt(limit as string, 10) : undefined;

        const maxDistanceMeters = maxDistance ? parseFloat(maxDistance as string) : undefined;

        if (isNaN(latitude) || isNaN(longitude) || (limit && isNaN(limitNum!)) || (maxDistance && isNaN(maxDistanceMeters!))) {
            return res.status(400).json({ message: 'Latitude, longitude, limit, and maxDistance must be valid numbers.' });
        }

        res.status(200).json(locations);
    } catch (error: any) {
        console.error('Error in getNearestLocations:', error);
        res.status(500).json({ message: 'Error fetching nearest locations', error: error.message }),
    }
}
}
}
}
}
}
}
}
}
}
}
}
}