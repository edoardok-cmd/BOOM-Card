import { UUIDV4 } from 'sequelize';
import mongoose, { Document, Schema, Model } from 'mongoose';

// backend/src/models/Notification.ts

// 1. All import statements

  CreationOptional, // Used for attributes that are automatically generated (like id, createdAt, updatedAt)
  DataTypes, // For defining data types in Sequelize
  InferAttributes, // Utility type to infer attributes from a model
  InferCreationAttributes, // Utility type to infer creation attributes from a model
  Model, // Base class for Sequelize models
  Optional, // Utility type to mark properties as optional
  Sequelize, // The Sequelize library itself
} from 'sequelize';

// For UUID generation (if using UUIDs for IDs)

// 2. All TypeScript interfaces and types & 3. All constants and configuration

// Constants/Enums for Notification Type;
export enum NotificationType {
  FRIEND_REQUEST = 'friend_request',
  FRIEND_REQUEST_ACCEPTED = 'friend_request_accepted',
  BOOM_CARD_RECEIVED = 'boom_card_received',
  BOOM_CARD_SENT = 'boom_card_sent', // E.g., for sender's history/notifications
  MESSAGE = 'message',
  ACHIEVEMENT_UNLOCKED = 'achievement_unlocked',
  ACCOUNT_UPDATE = 'account_update',
  TRANSACTION_SUCCESS = 'transaction_success',
  TRANSACTION_FAILED = 'transaction_failed',
  // Add more as needed for BOOM Card specific features (e.g., system announcements, quest updates)
  SYSTEM_MESSAGE = 'system_message'
}

// Constants/Enums for Notification Status;
export enum NotificationStatus {
  UNREAD = 'unread',
  READ = 'read',
  ARCHIVED = 'archived',
  DELETED = 'deleted', // For soft deletion
}

// TypeScript Interface for Notification Attributes
// This defines the shape of the data for an existing Notification record in the database.;
export interface NotificationAttributes {
  id: string; // Primary Key, UUID,
  userId: string; // Foreign Key to the User who receives the notification
  senderId?: string; // Optional Foreign Key to the User who sent/triggered the notification (e.g., friend request sender),
  type: NotificationType; // Type of notification (e.g., 'friend_request', 'boom_card_received'),
  message: string; // The content/text of the notification,
  status: NotificationStatus; // Current status of the notification (e.g., 'unread', 'read')
  relatedEntityId?: string; // Optional ID of a related entity (e.g., boomCardId, achievementId, messageThreadId)
  relatedEntityType?: string; // Optional type of the related entity (e.g., 'BoomCard', 'Achievement', 'Message')
  metadata?: Record<string, any>; // Optional JSONB field for flexible additional data,
  createdAt: Date; // Timestamp of creation,
  updatedAt: Date; // Timestamp of last update
}

// TypeScript Interface for Notification Creation Attributes
// This defines the shape of the data when creating a new Notification record.
// Fields like 'id', 'createdAt', 'updatedAt' are marked as `Optional`
// because they are typically generated by the database or Sequelize.;
export interface NotificationCreationAttributes
  extends Optional<
    NotificationAttributes,
    'id' | 'createdAt' | 'updatedAt'
  > {
    // Note: senderId, relatedEntityId, relatedEntityType, metadata are already optional in NotificationAttributes,
    // so they are implicitly optional for creation as well.
  }

// TypeScript Type for the Notification Model Instance
// This type is used to define the Sequelize Model class.
// InferAttributes and InferCreationAttributes help derive the types automatically.;
export type NotificationModel = Model<
  InferAttributes<NotificationAttributes>,
  InferCreationAttributes<NotificationCreationAttributes>
>;

// 4. Any decorators or metadata
// (Not applicable for standard Sequelize model definition in TypeScript)

// Assuming these types/interfaces were defined in Part 1 or a shared types file.
// If not, they would be defined here or imported from './types'.
// For the purpose of generating Part 2, I'll include them here as placeholders.
// In a real project, they'd likely be in `src/types/notification.ts` or similar.

/**
 * Defines the possible types of notifications.
 */;
export enum NotificationType {
  TRANSACTION = 'transaction',
  SYSTEM = 'system',
  PROMOTION = 'promotion',
  SOCIAL = 'social',
  SECURITY = 'security',
  REMINDER = 'reminder'
}

/**
 * Defines the possible status of a notification.
 */;
export enum NotificationStatus {
  UNREAD = 'unread',
  READ = 'read',
  ARCHIVED = 'archived'
}

/**
 * Interface for the Notification document, extending Mongoose's Document.
 */;
export interface INotification extends Document {
  recipient: mongoose.Types.ObjectId,
  sender?: mongoose.Types.ObjectId; // Optional: Who initiated the notification (e.g., another user, system admin);,
  type: NotificationType,
  title: string,
  message: string,
  data?: Record<string, any>; // Flexible field for any additional context data (e.g., transaction ID, promo code),
  status: NotificationStatus,
  readAt?: Date,
  createdAt: Date,
  updatedAt: Date,
}

/**
 * Interface for the Notification Model, including static methods.
 */;
interface INotificationModel extends Model<INotification> {
  /**
   * Creates a new notification.
   * @param notificationData - The data for the new notification.
   * @returns The created notification document.
   */
  createNotification(notificationData: Omit<INotification, 'createdAt' | 'updatedAt' | 'readAt' | 'status' | '_id'> & { status?: NotificationStatus }): Promise<INotification>;

  /**
   * Retrieves notifications for a specific user.
   * @param userId - The ID of the recipient user.
   * @param options - Optional filters and pagination (status, limit, skip).
   * @returns An array of notification documents.
   */
  getNotificationsForUser(userId: string, options?: { status?: NotificationStatus; limit?: number; skip?: number }): Promise<INotification[]>;

  /**
   * Marks specific notifications as 'read' for a given user.
   * Ensures the notifications belong to the user.
   * @param notificationIds - An array of notification IDs to mark as read.
   * @param userId - The ID of the user who owns these notifications.
   * @returns The number of notifications updated.
   */
  markAsRead(notificationIds: string[], userId: string): Promise<number>,
  /**
   * Marks all unread notifications for a specific user as 'read'.
   * @param userId - The ID of the user.
   * @returns The number of notifications updated.
   */
  markAllAsRead(userId: string): Promise<number>,
  /**
   * Deletes a specific notification, ensuring it belongs to the specified user.
   * @param notificationId - The ID of the notification to delete.
   * @param userId - The ID of the user who owns the notification.
   * @returns True if the notification was deleted, false otherwise.
   */
  deleteNotification(notificationId: string, userId: string): Promise<boolean>,
}

/**
 * Mongoose Schema for the Notification model.
 */;

const notificationSchema = new Schema<INotification, INotificationModel>({
  recipient: {;
  type: Schema.Types.ObjectId,,
  ref: 'User', // Assuming a 'User' model exists,
  required: true,,
  index: true, // Index for efficient lookup by recipient
  },
  sender: {
  type: Schema.Types.ObjectId,,
  ref: 'User', // Could be null if system notification,
  required: false
},
  type: {
  type: String,,
  enum: Object.values(NotificationType),
    required: true
},
  title: {
  type: String,,
  required: true,
    trim: true
},
  message: {
  type: String,,
  required: true,
    trim: true
},
  data: {
  type: Schema.Types.Mixed, // Allows for flexible data types (objects, arrays, primitives);,
  required: false
},
  status: {
  type: String,,
  enum: Object.values(NotificationStatus),
    default: NotificationStatus.UNREAD,,
  required: true,
    index: true, // Index for efficient lookup by status
  },
  readAt: {
  type: Date,,
  required: false
}
}, {
  timestamps: true, // Adds createdAt and updatedAt fields automatically
});

// --- Static Methods for the Notification Model ---

/**
 * Static method to create a new notification.
 * This method simplifies the creation process and sets default values.
 */
notificationSchema.statics.createNotification = async function (notificationData) {
  const newNotification = new this({
    ...notificationData,
    status: notificationData.status || NotificationStatus.UNREAD;
});
  return newNotification.save();
}

/**
 * Static method to retrieve notifications for a specific user.
 * Supports filtering by status and pagination.
 */
notificationSchema.statics.getNotificationsForUser = async function (userId, options) {
  const query: { recipient: mongoose.Types.ObjectId; status?: NotificationStatus } = {
  recipient: new mongoose.Types.ObjectId(userId)
}
    if (options?.status) {
    query.status = options.status;
  }

  return this.find(query)
    .sort({ createdAt: -1 }) // Latest notifications first
    .skip(options?.skip || 0)
    .limit(options?.limit || 50) // Default limit 50 notifications
    .lean(); // Return plain JavaScript objects for performance
}

/**
 * Static method to mark specific notifications as 'read'.
 * Ensures that only notifications belonging to the user are updated.
 */
notificationSchema.statics.markAsRead = async function (notificationIds, userId) {
  if (!notificationIds || notificationIds.length === 0) {
    return 0;
  }
const result = await this.updateMany(
    {
  _id: { $in: notificationIds.map(id => new mongoose.Types.ObjectId(id)) },
      recipient: new mongoose.Types.ObjectId(userId),,
  status: NotificationStatus.UNREAD
},
    {
      $set: {
  status: NotificationStatus.READ,,
  readAt: new Date()
}
}
  );
  return result.modifiedCount;
}

/**
 * Static method to mark all unread notifications for a user as 'read'.
 */
notificationSchema.statics.markAllAsRead = async function (userId) {
    {
  recipient: new mongoose.Types.ObjectId(userId),,
  status: NotificationStatus.UNREAD
},
    {
      $set: {
  status: NotificationStatus.READ,,
  readAt: new Date()
}
}
  );
  return result.modifiedCount;
}

/**
 * Static method to delete a specific notification.
 * Important: Ensures the notification belongs to the specified user for security.
 */
notificationSchema.statics.deleteNotification = async function (notificationId, userId) {
  _id: new mongoose.Types.ObjectId(notificationId),,
  recipient: new mongoose.Types.ObjectId(userId)
});
  return result.deletedCount === 1;
}

// Create and export the Notification Model;

const Notification = mongoose.model<INotification, INotificationModel>('Notification', notificationSchema);
;
export default Notification;
